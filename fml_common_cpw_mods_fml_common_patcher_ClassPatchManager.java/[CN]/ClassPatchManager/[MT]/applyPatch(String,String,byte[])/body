{
  if (patches == null) {
    return inputData;
  }
  List<ClassPatch> list=patches.get(name);
  if (list.isEmpty()) {
    return inputData;
  }
  FMLLog.fine("Runtime patching class %s (input size %d), found %d patch%s",mappedName,inputData.length,list.size(),list.size() != 1 ? "es" : "");
  for (  ClassPatch patch : list) {
    if (!patch.targetClassName.equals(mappedName)) {
      FMLLog.warning("Binary patch found %s for wrong class %s",patch.targetClassName,mappedName);
    }
    if (!patch.existsAtTarget && (inputData == null || inputData.length == 0)) {
      inputData=new byte[0];
    }
 else     if (!patch.existsAtTarget) {
      FMLLog.warning("Patcher expecting empty class data file for %s, but received non-empty",patch.targetClassName);
    }
synchronized (patcher) {
      try {
        inputData=patcher.patch(inputData,patch.patch);
      }
 catch (      IOException e) {
        FMLLog.log(Level.SEVERE,e,"Encountered problem runtime patching class %s",name);
        continue;
      }
    }
  }
  FMLLog.fine("Successfully applied runtime patches for %s (new size %d)",mappedName,inputData.length);
  if (dumpPatched) {
    try {
      Files.write(inputData,new File(tempDir,mappedName));
    }
 catch (    IOException e) {
      FMLLog.log(Level.SEVERE,e,"Failed to write %s to %s",mappedName,tempDir.getAbsolutePath());
    }
  }
  return inputData;
}

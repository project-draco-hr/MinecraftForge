{
  this.mouseX=mouseX;
  this.mouseY=mouseY;
  this.drawBackground();
  boolean isHovering=mouseX >= this.left && mouseX <= this.left + this.listWidth && mouseY >= this.top && mouseY <= this.bottom;
  int listLength=this.getSize();
  int scrollBarWidth=6;
  int scrollBarRight=this.left + this.listWidth;
  int scrollBarLeft=scrollBarRight - scrollBarWidth;
  int entryLeft=this.left;
  int entryRight=scrollBarLeft - 1;
  int viewHeight=this.bottom - this.top;
  int border=4;
  if (Mouse.isButtonDown(0)) {
    if (this.initialMouseClickY == -1.0F) {
      if (isHovering) {
        int mouseListY=mouseY - this.top - this.headerHeight + (int)this.scrollDistance - border;
        int slotIndex=mouseListY / this.slotHeight;
        if (mouseX >= entryLeft && mouseX <= entryRight && slotIndex >= 0 && mouseListY >= 0 && slotIndex < listLength) {
          this.elementClicked(slotIndex,slotIndex == this.selectedIndex && System.currentTimeMillis() - this.lastClickTime < 250L);
          this.selectedIndex=slotIndex;
          this.lastClickTime=System.currentTimeMillis();
        }
 else         if (mouseX >= entryLeft && mouseX <= entryRight && mouseListY < 0) {
          this.clickHeader(mouseX - entryLeft,mouseY - this.top + (int)this.scrollDistance - border);
        }
        if (mouseX >= scrollBarLeft && mouseX <= scrollBarRight) {
          this.scrollFactor=-1.0F;
          int scrollHeight=this.getContentHeight() - viewHeight - border;
          if (scrollHeight < 1)           scrollHeight=1;
          int var13=(int)((float)(viewHeight * viewHeight) / (float)this.getContentHeight());
          if (var13 < 32)           var13=32;
          if (var13 > viewHeight - border * 2)           var13=viewHeight - border * 2;
          this.scrollFactor/=(float)(viewHeight - var13) / (float)scrollHeight;
        }
 else {
          this.scrollFactor=1.0F;
        }
        this.initialMouseClickY=mouseY;
      }
 else {
        this.initialMouseClickY=-2.0F;
      }
    }
 else     if (this.initialMouseClickY >= 0.0F) {
      this.scrollDistance-=((float)mouseY - this.initialMouseClickY) * this.scrollFactor;
      this.initialMouseClickY=(float)mouseY;
    }
  }
 else {
    while (isHovering && Mouse.next()) {
      int scroll=Mouse.getEventDWheel();
      if (scroll != 0) {
        if (scroll > 0)         scroll=-1;
 else         if (scroll < 0)         scroll=1;
        this.scrollDistance+=(float)(scroll * this.slotHeight / 2);
      }
    }
    this.initialMouseClickY=-1.0F;
  }
  this.applyScrollLimits();
  Tessellator tess=Tessellator.getInstance();
  WorldRenderer worldr=tess.getWorldRenderer();
  if (this.client.theWorld != null) {
    this.drawGradientRect(this.left,this.top,this.right,this.bottom,0xC0101010,0xD0101010);
  }
 else {
    GlStateManager.disableLighting();
    GlStateManager.disableFog();
    this.client.renderEngine.bindTexture(Gui.optionsBackground);
    GlStateManager.color(1.0F,1.0F,1.0F,1.0F);
    float scale=32.0F;
    worldr.startDrawingQuads();
    worldr.setColorOpaque_I(2105376);
    worldr.addVertexWithUV(this.left,this.bottom,0.0D,this.left / scale,(this.bottom + (int)this.scrollDistance) / scale);
    worldr.addVertexWithUV(this.right,this.bottom,0.0D,this.right / scale,(this.bottom + (int)this.scrollDistance) / scale);
    worldr.addVertexWithUV(this.right,this.top,0.0D,this.right / scale,(this.top + (int)this.scrollDistance) / scale);
    worldr.addVertexWithUV(this.left,this.top,0.0D,this.left / scale,(this.top + (int)this.scrollDistance) / scale);
    tess.draw();
  }
  int baseY=this.top + border - (int)this.scrollDistance;
  if (this.hasHeader) {
    this.drawHeader(entryRight,baseY,tess);
  }
  for (int slotIdx=0; slotIdx < listLength; ++slotIdx) {
    int slotTop=baseY + slotIdx * this.slotHeight + this.headerHeight;
    int slotBuffer=this.slotHeight - border;
    if (slotTop <= this.bottom && slotTop + slotBuffer >= this.top) {
      if (this.highlightSelected && this.isSelected(slotIdx)) {
        int min=this.left;
        int max=entryRight;
        GlStateManager.color(1.0F,1.0F,1.0F,1.0F);
        GlStateManager.disableTexture2D();
        worldr.startDrawingQuads();
        worldr.setColorOpaque_I(0x808080);
        worldr.addVertexWithUV(min,slotTop + slotBuffer + 2,0.0D,0.0D,1.0D);
        worldr.addVertexWithUV(max,slotTop + slotBuffer + 2,0.0D,1.0D,1.0D);
        worldr.addVertexWithUV(max,slotTop - 2,0.0D,1.0D,0.0D);
        worldr.addVertexWithUV(min,slotTop - 2,0.0D,0.0D,0.0D);
        worldr.setColorOpaque_I(0);
        worldr.addVertexWithUV(min + 1,slotTop + slotBuffer + 1,0.0D,0.0D,1.0D);
        worldr.addVertexWithUV(max - 1,slotTop + slotBuffer + 1,0.0D,1.0D,1.0D);
        worldr.addVertexWithUV(max - 1,slotTop - 1,0.0D,1.0D,0.0D);
        worldr.addVertexWithUV(min + 1,slotTop - 1,0.0D,0.0D,0.0D);
        tess.draw();
        GlStateManager.enableTexture2D();
      }
      this.drawSlot(slotIdx,entryRight,slotTop,slotBuffer,tess);
    }
  }
  GlStateManager.disableDepth();
  if (this.client.theWorld == null) {
    this.overlayBackground(0,this.top,255,255);
    this.overlayBackground(this.bottom,this.listHeight,255,255);
  }
  GlStateManager.enableBlend();
  GlStateManager.blendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GlStateManager.disableAlpha();
  GlStateManager.shadeModel(GL11.GL_SMOOTH);
  GlStateManager.disableTexture2D();
  worldr.startDrawingQuads();
  worldr.setColorRGBA_I(0,0);
  worldr.addVertexWithUV(this.left,this.top + border,0.0D,0.0D,1.0D);
  worldr.addVertexWithUV(this.right,this.top + border,0.0D,1.0D,1.0D);
  worldr.setColorRGBA_I(0,255);
  worldr.addVertexWithUV(this.right,this.top,0.0D,1.0D,0.0D);
  worldr.addVertexWithUV(this.left,this.top,0.0D,0.0D,0.0D);
  tess.draw();
  worldr.startDrawingQuads();
  worldr.setColorRGBA_I(0,255);
  worldr.addVertexWithUV(this.left,this.bottom,0.0D,0.0D,1.0D);
  worldr.addVertexWithUV(this.right,this.bottom,0.0D,1.0D,1.0D);
  worldr.setColorRGBA_I(0,0);
  worldr.addVertexWithUV(this.right,this.bottom - border,0.0D,1.0D,0.0D);
  worldr.addVertexWithUV(this.left,this.bottom - border,0.0D,0.0D,0.0D);
  tess.draw();
  int extraHeight=this.getContentHeight() - viewHeight - border;
  if (extraHeight > 0) {
    int height=viewHeight * viewHeight / this.getContentHeight();
    if (height < 32)     height=32;
    if (height > viewHeight - border * 2)     height=viewHeight - border * 2;
    int barTop=(int)this.scrollDistance * (viewHeight - height) / extraHeight + this.top;
    if (barTop < this.top) {
      barTop=this.top;
    }
    worldr.startDrawingQuads();
    worldr.setColorRGBA_I(0,255);
    worldr.addVertexWithUV(scrollBarLeft,this.bottom,0.0D,0.0D,1.0D);
    worldr.addVertexWithUV(scrollBarRight,this.bottom,0.0D,1.0D,1.0D);
    worldr.addVertexWithUV(scrollBarRight,this.top,0.0D,1.0D,0.0D);
    worldr.addVertexWithUV(scrollBarLeft,this.top,0.0D,0.0D,0.0D);
    tess.draw();
    worldr.startDrawingQuads();
    worldr.setColorRGBA_I(0x808080,255);
    worldr.addVertexWithUV(scrollBarLeft,barTop + height,0.0D,0.0D,1.0D);
    worldr.addVertexWithUV(scrollBarRight,barTop + height,0.0D,1.0D,1.0D);
    worldr.addVertexWithUV(scrollBarRight,barTop,0.0D,1.0D,0.0D);
    worldr.addVertexWithUV(scrollBarLeft,barTop,0.0D,0.0D,0.0D);
    tess.draw();
    worldr.startDrawingQuads();
    worldr.setColorRGBA_I(0xC0C0C0,255);
    worldr.addVertexWithUV(scrollBarLeft,barTop + height - 1,0.0D,0.0D,1.0D);
    worldr.addVertexWithUV(scrollBarRight - 1,barTop + height - 1,0.0D,1.0D,1.0D);
    worldr.addVertexWithUV(scrollBarRight - 1,barTop,0.0D,1.0D,0.0D);
    worldr.addVertexWithUV(scrollBarLeft,barTop,0.0D,0.0D,0.0D);
    tess.draw();
  }
  this.drawScreen(mouseX,mouseY);
  GlStateManager.enableTexture2D();
  GlStateManager.shadeModel(GL11.GL_FLAT);
  GlStateManager.enableAlpha();
  GlStateManager.disableBlend();
}

{
  File configDir=Loader.instance().getConfigDir();
  String modConfigName=modClazz.getSimpleName();
  File modConfig=new File(configDir,String.format("%s.cfg",modConfigName));
  Properties props=new Properties();
  if (modConfig.exists()) {
    try {
      Loader.log.fine(String.format("Reading existing configuration file for %s : %s",modConfigName,modConfig.getName()));
      FileReader configReader=new FileReader(modConfig);
      props.load(configReader);
      configReader.close();
    }
 catch (    Exception e) {
      Loader.log.severe(String.format("Error occured reading mod configuration file %s",modConfig.getName()));
      Loader.log.throwing("ModLoaderModContainer","configureMod",e);
      throw new LoaderException(e);
    }
  }
  StringBuffer comments=new StringBuffer();
  comments.append("MLProperties: name (type:default) min:max -- information\n");
  try {
    for (    Field f : modClazz.getDeclaredFields()) {
      if (!Modifier.isStatic(f.getModifiers())) {
        continue;
      }
      if (!f.isAnnotationPresent(MLProp.class)) {
        continue;
      }
      MLProp property=f.getAnnotation(MLProp.class);
      String propertyName=property.name().length() > 0 ? property.name() : f.getName();
      String propertyValue=null;
      Object defaultValue=null;
      try {
        defaultValue=f.get(null);
        propertyValue=props.getProperty(propertyName,extractValue(defaultValue));
        Object currentValue=parseValue(propertyValue,property,f.getType(),propertyName,modConfigName);
        Loader.log.finest(String.format("Configuration for %s.%s found values default: %s, configured: %s, interpreted: %s",modConfigName,propertyName,defaultValue,propertyValue,currentValue));
        if (currentValue != null && !currentValue.equals(defaultValue)) {
          Loader.log.finest(String.format("Configuration for %s.%s value set to: %s",modConfigName,propertyName,currentValue));
          f.set(null,currentValue);
        }
      }
 catch (      Exception e) {
        Loader.log.severe(String.format("Invalid configuration found for %s in %s",propertyName,modConfig.getName()));
        Loader.log.throwing("ModLoaderModContainer","configureMod",e);
        throw new LoaderException(e);
      }
 finally {
        comments.append(String.format("MLProp : %s (%s:%s",propertyName,f.getType().getName(),defaultValue));
        if (property.min() != Double.MIN_VALUE) {
          comments.append(",>=").append(String.format("%.1f",property.min()));
        }
        if (property.max() != Double.MAX_VALUE) {
          comments.append(",<=").append(String.format("%.1f",property.max()));
        }
        comments.append(")");
        if (property.info().length() > 0) {
          comments.append(" -- ").append(property.info());
        }
        if (propertyValue != null) {
          props.setProperty(propertyName,extractValue(propertyValue));
        }
        comments.append("\n");
      }
    }
  }
  finally {
    try {
      FileWriter configWriter=new FileWriter(modConfig);
      props.store(configWriter,comments.toString());
      configWriter.close();
      Loader.log.fine(String.format("Configuration for %s written to %s",modConfigName,modConfig.getName()));
    }
 catch (    IOException e) {
      Loader.log.warning(String.format("Error trying to write the config file %s",modConfig.getName()));
      Loader.log.throwing("ModLoaderModContainer","configureMod",e);
      throw new LoaderException(e);
    }
  }
}

def main():
    parser = OptionParser()
    parser.add_option('-m', '--mcp-dir', action='store', dest='mcp_dir', help='MCP install folder', default='mcp')
    parser.add_option('-f', '--fml-dir', action='store', dest='fml_dir', help='FML instlal folder', default='.')
    (options, _) = parser.parse_args()
    sys.path.append(os.path.join(options.fml_dir, 'install'))
    from fml import read_mc_versions, load_srg
    info = read_mc_versions(options.fml_dir, work_dir=os.path.join(options.mcp_dir, 'jars'))
    types = {'client': [], 'server': [], }
    for type in ['client', 'server']:
        with closing(ZipFile(info[('%s_file' % type)])) as zip:
            for i in zip.filelist:
                if (i.filename.endswith('.class') and (i.filename.find('/') == (-1))):
                    types[type].append(i.filename[:(-6)])
    srg = get_merged_info(options.fml_dir, options.mcp_dir)
    pkgs = {}
    pkg_file = os.path.join('conf', 'packages.csv')
    if os.path.isfile(pkg_file):
        with closing(open(pkg_file)) as fh:
            reader = csv.DictReader(fh)
            for line in reader:
                pkgs[line['class']] = line['package']
    classes = []
    for cls in srg['CL:'].keys():
        if cls.startswith('net/minecraft/src/'):
            obf = srg['CL:'][cls]
            cls = cls[18:]
            classes.append(cls)
            for type in ['server', 'client']:
                if (obf in types[type]):
                    types[type].remove(obf)
                    types[type].append(cls)
    for cls in pkgs.keys():
        if (not (cls in classes)):
            print ('Removed Class: %s/%s' % (pkgs[cls], cls))
            pkgs.pop(cls)
    for cls in classes:
        if (not (cls in pkgs.keys())):
            print ('New Class: %s' % cls)
            if (cls.find('/') == (-1)):
                if ((cls in types['server']) and (cls in types['client'])):
                    pkgs[cls] = 'get_me_out_of_here_shared'
                elif (cls in types['server']):
                    pkgs[cls] = 'get_me_out_of_here_server'
                elif (cls in types['client']):
                    pkgs[cls] = 'get_me_out_of_here_client'
                else:
                    pkgs[cls] = 'get_me_out_of_here_src'
    tmp = []
    for (cls, pkg) in pkgs.items():
        tmp.append({'class': cls, 'package': pkg, })
    with closing(open(pkg_file, 'wb')) as fh:
        writer = csv.DictWriter(fh, fieldnames=['class', 'package'], lineterminator='\n')
        writer.writeheader()
        for row in sorted(tmp, key=(lambda x: (x['package'], x['class']))):
            writer.writerow(row)

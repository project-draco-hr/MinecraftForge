def setup_fml(fml_dir, mcp_dir, disable_at=False, disable_merge=False, enable_server=False, disable_client=False):
    global compile_tools
    sys.path.append(mcp_dir)
    from runtime.decompile import decompile
    from runtime.cleanup import cleanup
    from runtime.commands import Commands, CLIENT, SERVER
    src_dir = os.path.join(mcp_dir, 'src')
    if os.path.isdir(src_dir):
        os.chdir(mcp_dir)
        cleanup(None, False)
        reset_logger()
        os.chdir(fml_dir)
    if os.path.isdir(src_dir):
        print 'Please make sure to backup your modified files, and say yes when it asks you to do cleanup.'
        sys.exit(1)
    if (not download_deps(mcp_dir)):
        sys.exit(1)
    compile_tools = True

    def applyrg_shunt(self, side, reobf=False, applyrg_real=Commands.applyrg):
        global compile_tools
        if ((not self.has_wine) and (not self.has_astyle)):
            self.logger.error('!! Please install either wine or astyle for source cleanup !!')
            self.logger.error('!! This is REQUIRED by FML/Forge Cannot proceed !!')
            sys.exit(1)
        jars = {CLIENT: self.jarclient, SERVER: self.jarserver, }
        dir_bin = os.path.join(fml_dir, 'bin')
        if (not os.path.isdir(dir_bin)):
            os.makedirs(dir_bin)
        class_path = os.pathsep.join(['.', os.path.join(mcp_dir, 'lib', '*'), dir_bin])
        dir_common = os.path.join(fml_dir, 'common')
        dir_trans = os.path.join(dir_common, 'cpw', 'mods', 'fml', 'common', 'asm', 'transformers')
        java = self.cmdjava.translate(None, '"')
        javac = self.cmdjavac.translate(None, '"')
        cmd_compile = ('"%s" -Xlint:-options -deprecation -g -source 1.6 -target 1.6 -classpath "{classpath}" -sourcepath "{sourcepath}" -d "{outpath}" "{target}"' % javac)
        cmd_compile = cmd_compile.format(classpath=class_path, sourcepath=dir_common, outpath=dir_bin, target='{target}')
        if compile_tools:
            self.logger.info('> Compiling AccessTransformer')
            if (not runcmd(self, cmd_compile.format(target=os.path.join(dir_trans, 'AccessTransformer.java')), echo=False)):
                sys.exit(1)
            self.logger.info('> Compiling MCPMerger')
            if (not runcmd(self, cmd_compile.format(target=os.path.join(dir_trans, 'MCPMerger.java')), echo=False)):
                sys.exit(1)
            compile_tools = False
        if (side == CLIENT):
            if (not disable_merge):
                self.logger.info('> Running MCPMerger')
                forkcmd = ('"%s" -classpath "{classpath}" cpw.mods.fml.common.asm.transformers.MCPMerger "{mergecfg}" "{client}" "{server}"' % java).format(classpath=class_path, mergecfg=os.path.join(fml_dir, 'mcp_merge.cfg'), client=jars[CLIENT], server=jars[SERVER])
                if (not runcmd(self, forkcmd)):
                    sys.exit(1)
            else:
                self.logger.info('> MCPMerge disabled')
        if (not disable_at):
            self.logger.info('> Running AccessTransformer')
            forkcmd = ('"%s" -classpath "{classpath}" cpw.mods.fml.common.asm.transformers.AccessTransformer "{jar}" "{fmlconfig}"' % java).format(classpath=class_path, jar=jars[side], fmlconfig=os.path.join(fml_dir, 'common', 'fml_at.cfg'))
            forge_cfg = os.path.join(fml_dir, '..', 'common', 'forge_at.cfg')
            if os.path.isfile(forge_cfg):
                self.logger.info('   Forge config detected')
                forkcmd += (' "%s"' % forge_cfg)
            for (dirname, dirnames, filenames) in os.walk(os.path.join(fml_dir, '..', 'accesstransformers')):
                for filename in filenames:
                    accesstransformer = os.path.join(dirname, filename)
                    if os.path.isfile(accesstransformer):
                        self.logger.info(('   Access Transformer "%s" detected' % filename))
                        forkcmd += (' "%s"' % accesstransformer)
            if (not runcmd(self, forkcmd)):
                sys.exit(1)
        else:
            self.logger.info('> Access Transformer disabled')
        self.logger.info('> Really Applying Retroguard')
        applyrg_real(self, side, reobf)

    def checkjars_shunt(self, side, checkjars_real=Commands.checkjars):
        self.jarclient = (self.jarclient + '.backup')
        self.jarserver = (self.jarserver + '.backup')
        ret = checkjars_real(self, side)
        self.jarclient = self.jarclient[:(-7)]
        self.jarserver = self.jarserver[:(-7)]
        return ret
    try:
        pre_decompile(mcp_dir, fml_dir)
        os.chdir(mcp_dir)
        Commands.applyrg = applyrg_shunt
        Commands.checkjars = checkjars_shunt
        decompile(None, False, False, True, True, False, True, False, False, False, False, (not disable_client), enable_server)
        reset_logger()
        os.chdir(fml_dir)
        post_decompile(mcp_dir, fml_dir)
    except SystemExit as e:
        print ('Decompile Exception: %d ' % e.code)
        raise e
    if (not os.path.isdir(src_dir)):
        print ('Something went wrong, src folder not found at: %s' % src_dir)
        sys.exit(1)
    cleanup_source(src_dir)
    os.chdir(mcp_dir)
    commands = Commands(verify=True)
    if (not disable_client):
        updatemd5_side(mcp_dir, commands, CLIENT)
        reset_logger()
    if enable_server:
        updatemd5_side(mcp_dir, commands, CLIENT)
        reset_logger()
    os.chdir(fml_dir)

{
  isLoading=true;
  loadBlocks();
  loadVariantItemModels();
  missingModel=ModelLoaderRegistry.getMissingModel();
  stateModels.put(MODEL_MISSING,missingModel);
  final Set<ResourceLocation> textures=Sets.newHashSet(ModelLoaderRegistry.getTextures());
  textures.remove(TextureMap.LOCATION_MISSING_TEXTURE);
  textures.addAll(LOCATIONS_BUILTIN_TEXTURES);
  textureMap.loadSprites(resourceManager,new IIconCreator(){
    public void registerSprites(    TextureMap map){
      for (      ResourceLocation t : textures) {
        map.registerSprite(t);
      }
    }
  }
);
  IBakedModel missingBaked=missingModel.bake(missingModel.getDefaultState(),DefaultVertexFormats.ITEM,DefaultTextureGetter.instance);
  Map<IModel,IBakedModel> bakedModels=Maps.newHashMap();
  for (  IModel model : stateModels.values()) {
    if (model == getMissingModel()) {
      bakedModels.put(model,missingBaked);
    }
 else {
      bakedModels.put(model,model.bake(model.getDefaultState(),DefaultVertexFormats.ITEM,DefaultTextureGetter.instance));
    }
  }
  for (  Entry<ModelResourceLocation,IModel> e : stateModels.entrySet()) {
    bakedRegistry.putObject(e.getKey(),bakedModels.get(e.getValue()));
  }
  return bakedRegistry;
}

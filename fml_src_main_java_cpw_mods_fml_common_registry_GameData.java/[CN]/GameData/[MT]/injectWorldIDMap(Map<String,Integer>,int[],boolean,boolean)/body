{
  FMLLog.info("Injecting existing block and item data into this %s instance",FMLCommonHandler.instance().getEffectiveSide().isServer() ? "server" : "client");
  Map<String,Integer[]> remaps=Maps.newHashMap();
  LinkedHashMap<String,Integer> missingMappings=new LinkedHashMap<String,Integer>();
  getMain().testConsistency();
  getMain().iBlockRegistry.dump();
  getMain().iItemRegistry.dump();
  GameData newData=new GameData();
  for (  int id : blockedIds) {
    newData.block(id);
  }
  for (int pass=0; pass < 2; pass++) {
    boolean isBlock=(pass == 0);
    for (    Entry<String,Integer> entry : dataList.entrySet()) {
      String itemName=entry.getKey();
      int newId=entry.getValue();
      if ((itemName.charAt(0) == '\u0001') != isBlock)       continue;
      itemName=itemName.substring(1);
      int currId=isBlock ? getMain().iBlockRegistry.getId(itemName) : getMain().iItemRegistry.getId(itemName);
      if (currId == -1) {
        FMLLog.info("Found a missing id from the world %s",itemName);
        missingMappings.put(itemName,newId);
        continue;
      }
 else       if (currId != newId) {
        FMLLog.info("Found %s id mismatch %s : %d (was %d)",isBlock ? "block" : "item",itemName,currId,newId);
        remaps.put(itemName,new Integer[]{currId,newId});
      }
      if (isBlock) {
        Block block=getMain().iBlockRegistry.getRaw(itemName);
        if (block == null)         throw new IllegalStateException(String.format("Can't find block for name %s, id %d",itemName,currId));
        currId=newData.registerBlock(block,itemName,null,newId);
      }
 else {
        Item item=getMain().iItemRegistry.getRaw(itemName);
        if (item == null)         throw new IllegalStateException(String.format("Can't find item for name %s, id %d",itemName,currId));
        currId=newData.registerItem(item,itemName,null,newId);
      }
      if (currId != newId) {
        throw new IllegalStateException(String.format("Can't map %s %s to id %d, already occupied by %s",isBlock ? "block" : "item",itemName,newId,isBlock ? newData.iBlockRegistry.get(newId) : newData.iItemRegistry.get(newId)));
      }
    }
  }
  List<String> missedMappings=Loader.instance().fireMissingMappingEvent(missingMappings,isLocalWorld,newData);
  if (!missedMappings.isEmpty())   return missedMappings;
  if (injectFrozenData) {
    FMLLog.info("Injecting new block and item data into this server instance");
    Map<String,Integer> missingBlocks=frozen.iBlockRegistry.getEntriesNotIn(newData.iBlockRegistry);
    Map<String,Integer> missingItems=frozen.iItemRegistry.getEntriesNotIn(newData.iItemRegistry);
    for (int pass=0; pass < 2; pass++) {
      boolean isBlock=pass == 0;
      Map<String,Integer> missing=(pass == 0) ? missingBlocks : missingItems;
      for (      Entry<String,Integer> entry : missing.entrySet()) {
        String itemName=entry.getKey();
        int currId=entry.getValue();
        int newId;
        if (isBlock) {
          newId=newData.registerBlock(frozen.iBlockRegistry.get(itemName),itemName,null,currId);
        }
 else {
          newId=newData.registerItem(frozen.iItemRegistry.get(itemName),itemName,null,currId);
        }
        FMLLog.info("Injected new block/item %s : %d (was %d)",itemName,newId,currId);
        if (newId != currId) {
          remaps.put(itemName,new Integer[]{entry.getValue(),newId});
        }
      }
    }
  }
  newData.testConsistency();
  getMain().set(newData);
  getMain().iBlockRegistry.dump();
  getMain().iItemRegistry.dump();
  Loader.instance().fireRemapEvent(remaps);
  return ImmutableList.of();
}

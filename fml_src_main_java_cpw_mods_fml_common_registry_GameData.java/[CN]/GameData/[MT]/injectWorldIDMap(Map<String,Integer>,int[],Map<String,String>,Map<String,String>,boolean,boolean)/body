{
  FMLLog.info("Injecting existing block and item data into this %s instance",FMLCommonHandler.instance().getEffectiveSide().isServer() ? "server" : "client");
  Map<String,Integer[]> remaps=Maps.newHashMap();
  LinkedHashMap<String,Integer> missingMappings=new LinkedHashMap<String,Integer>();
  getMain().testConsistency();
  getMain().iBlockRegistry.dump();
  getMain().iItemRegistry.dump();
  GameData newData=new GameData();
  for (  int id : blockedIds) {
    newData.block(id);
  }
  for (  Map.Entry<String,String> entry : blockAliases.entrySet()) {
    newData.iBlockRegistry.addAlias(entry.getKey(),entry.getValue());
  }
  for (  Map.Entry<String,String> entry : itemAliases.entrySet()) {
    newData.iItemRegistry.addAlias(entry.getKey(),entry.getValue());
  }
  for (int pass=0; pass < 2; pass++) {
    boolean isBlock=(pass == 0);
    for (    Entry<String,Integer> entry : dataList.entrySet()) {
      String itemName=entry.getKey();
      int newId=entry.getValue();
      if ((itemName.charAt(0) == '\u0001') != isBlock)       continue;
      itemName=itemName.substring(1);
      int currId=isBlock ? getMain().iBlockRegistry.getId(itemName) : getMain().iItemRegistry.getId(itemName);
      if (currId == -1) {
        FMLLog.info("Found a missing id from the world %s",itemName);
        missingMappings.put(entry.getKey(),newId);
        continue;
      }
 else       if (currId != newId) {
        FMLLog.info("Found %s id mismatch %s : %d (was %d)",isBlock ? "block" : "item",itemName,currId,newId);
        remaps.put(itemName,new Integer[]{currId,newId});
      }
      FMLControlledNamespacedRegistry<?> srcRegistry=isBlock ? getMain().iBlockRegistry : getMain().iItemRegistry;
      currId=newData.register(srcRegistry.getRaw(itemName),itemName,newId);
      if (currId != newId) {
        throw new IllegalStateException(String.format("Can't map %s %s to id %d, already occupied by %s",isBlock ? "block" : "item",itemName,newId,isBlock ? newData.iBlockRegistry.get(newId) : newData.iItemRegistry.get(newId)));
      }
    }
  }
  List<String> missedMappings=Loader.instance().fireMissingMappingEvent(missingMappings,isLocalWorld,newData,remaps);
  if (!missedMappings.isEmpty())   return missedMappings;
  if (injectFrozenData) {
    FMLLog.info("Injecting new block and item data into this server instance");
    Map<String,Integer> missingBlocks=frozen.iBlockRegistry.getEntriesNotIn(newData.iBlockRegistry);
    Map<String,Integer> missingItems=frozen.iItemRegistry.getEntriesNotIn(newData.iItemRegistry);
    for (int pass=0; pass < 2; pass++) {
      boolean isBlock=pass == 0;
      Map<String,Integer> missing=(pass == 0) ? missingBlocks : missingItems;
      for (      Entry<String,Integer> entry : missing.entrySet()) {
        String itemName=entry.getKey();
        int currId=entry.getValue();
        int newId;
        if (isBlock) {
          newId=newData.registerBlock(frozen.iBlockRegistry.get(itemName),itemName,null,currId);
        }
 else {
          newId=newData.registerItem(frozen.iItemRegistry.get(itemName),itemName,null,currId);
        }
        FMLLog.info("Injected new block/item %s : %d (was %d)",itemName,newId,currId);
        if (newId != currId) {
          remaps.put(itemName,new Integer[]{entry.getValue(),newId});
        }
      }
    }
  }
  newData.testConsistency();
  getMain().set(newData);
  getMain().iBlockRegistry.dump();
  getMain().iItemRegistry.dump();
  Loader.instance().fireRemapEvent(remaps);
  return ImmutableList.of();
}

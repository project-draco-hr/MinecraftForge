{
  BitSet availabilityMap=new BitSet(MAX_ITEM_ID + 1);
  for (  Entry<String,Integer> entry : blocks.ids.entrySet()) {
    availabilityMap.set(entry.getValue());
  }
  Set<Integer> newBlockedIds=new HashSet<Integer>();
  Set<String> itemsToRemove=new HashSet<String>();
  Map<String,Integer> itemsToRelocate=new HashMap<String,Integer>();
  for (  Entry<String,Integer> entry : items.ids.entrySet()) {
    int oldId=entry.getValue();
    String name=entry.getKey();
    Item item=getMain().iItemRegistry.getRaw(name);
    boolean blockThisId=false;
    if (item == null) {
      FMLLog.warning("Item %s (old id %d) is no longer available and thus can't be fixed.",name,oldId);
      itemsToRemove.add(name);
      blockThisId=true;
    }
 else     if (item instanceof ItemBlock) {
      if (blocks.ids.containsKey(name)) {
        int blockId=blocks.ids.get(name);
        if (blockId != oldId) {
          FMLLog.warning("ItemBlock %s (old id %d) doesn't have the same id as its block (%d).",name,oldId,blockId);
          itemsToRelocate.put(name,blockId);
          blockThisId=true;
        }
 else {
          availabilityMap.set(oldId);
        }
      }
 else {
        FMLLog.warning("Item %s (old id %d) has been migrated to an ItemBlock and can't be fixed.",name,oldId);
        itemsToRemove.add(name);
        blockThisId=true;
      }
    }
 else     if (availabilityMap.get(oldId)) {
      FMLLog.warning("Item %s (old id %d) is conflicting with another block/item and can't be fixed.",name,oldId);
      itemsToRemove.add(name);
    }
 else {
      availabilityMap.set(oldId);
    }
    if (blockThisId && !availabilityMap.get(oldId)) {
      newBlockedIds.add(oldId);
      availabilityMap.set(oldId);
    }
  }
  if (itemsToRemove.isEmpty() && itemsToRelocate.isEmpty())   return;
  String text="Forge Mod Loader detected that this save is damaged.\n\n" + "It's likely that an automatic repair can successfully restore\n" + "most of it, except some items which may get swapped with others.\n\n"+ "A world backup will be created as a zip file in your saves\n"+ "directory automatically.\n\n" + itemsToRemove.size() + " items need to be removed.\n"+ itemsToRelocate.size()+ " items need to be relocated.";
  boolean confirmed=StartupQuery.confirm(text);
  if (!confirmed)   StartupQuery.abort();
  Set<String> modsMissing=new HashSet<String>();
  for (  String name : itemsToRemove) {
    modsMissing.add(name.substring(0,name.indexOf(':')));
  }
  for (Iterator<String> it=modsMissing.iterator(); it.hasNext(); ) {
    String mod=it.next();
    if (mod.equals("minecraft") || Loader.isModLoaded(mod))     it.remove();
  }
  if (!modsMissing.isEmpty()) {
    text="Forge Mod Loader detected that " + modsMissing.size() + " mods are missing.\n\n"+ "If you continue items previously provided by those mods will be\n"+ "removed while repairing this world save.\n\n"+ "Missing mods:\n";
    for (    String mod : modsMissing)     text+=mod + "\n";
    confirmed=StartupQuery.confirm(text);
    if (!confirmed)     StartupQuery.abort();
  }
  try {
    String skip=System.getProperty("fml.doNotBackup");
    if (skip == null || !"true".equals(skip)) {
      ZipperUtil.backupWorld();
    }
 else {
      for (int x=0; x < 10; x++)       FMLLog.severe("!!!!!!!!!! UPDATING WORLD WITHOUT DOING BACKUP !!!!!!!!!!!!!!!!");
    }
  }
 catch (  IOException e) {
    StartupQuery.notify("The world backup couldn't be created.\n\n" + e);
    StartupQuery.abort();
  }
  for (  String name : itemsToRemove) {
    FMLLog.warning("Removed Item %s, old id %d.",name,items.ids.remove(name));
  }
  for (  Map.Entry<String,Integer> entry : itemsToRelocate.entrySet()) {
    int newId=entry.getValue();
    int oldId=items.ids.put(entry.getKey(),newId);
    FMLLog.warning("Remapped Item %s to id %d, old id %d.",entry.getKey(),newId,oldId);
  }
  blockedIds.addAll(newBlockedIds);
}

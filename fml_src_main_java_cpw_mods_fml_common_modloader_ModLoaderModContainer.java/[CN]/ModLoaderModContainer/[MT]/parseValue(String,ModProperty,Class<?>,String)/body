{
  if (type.isAssignableFrom(String.class)) {
    return (String)val;
  }
 else   if (type.isAssignableFrom(Boolean.TYPE) || type.isAssignableFrom(Boolean.class)) {
    return Boolean.parseBoolean(val);
  }
 else   if (Number.class.isAssignableFrom(type) || type.isPrimitive()) {
    Number n=null;
    if (type.isAssignableFrom(Double.TYPE) || Double.class.isAssignableFrom(type)) {
      n=Double.parseDouble(val);
    }
 else     if (type.isAssignableFrom(Float.TYPE) || Float.class.isAssignableFrom(type)) {
      n=Float.parseFloat(val);
    }
 else     if (type.isAssignableFrom(Long.TYPE) || Long.class.isAssignableFrom(type)) {
      n=Long.parseLong(val);
    }
 else     if (type.isAssignableFrom(Integer.TYPE) || Integer.class.isAssignableFrom(type)) {
      n=Integer.parseInt(val);
    }
 else     if (type.isAssignableFrom(Short.TYPE) || Short.class.isAssignableFrom(type)) {
      n=Short.parseShort(val);
    }
 else     if (type.isAssignableFrom(Byte.TYPE) || Byte.class.isAssignableFrom(type)) {
      n=Byte.parseByte(val);
    }
 else {
      throw new IllegalArgumentException(String.format("MLProp declared on %s of type %s, an unsupported type",propertyName,type.getName()));
    }
    double dVal=n.doubleValue();
    if ((property.min() != Double.MIN_VALUE && dVal < property.min()) || (property.max() != Double.MAX_VALUE && dVal > property.max())) {
      FMLLog.warning("Configuration for %s.%s found value %s outside acceptable range %s,%s",modClazzName,propertyName,n,property.min(),property.max());
      return null;
    }
 else {
      return n;
    }
  }
  throw new IllegalArgumentException(String.format("MLProp declared on %s of type %s, an unsupported type",propertyName,type.getName()));
}

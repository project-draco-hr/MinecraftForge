{
  for (  VertexFormatElement e : (List<VertexFormatElement>)format.getElements()) {
    if (e.getUsage() == VertexFormatElement.EnumUsage.POSITION) {
      if (e.getType() != VertexFormatElement.EnumType.FLOAT) {
        throw new IllegalArgumentException("can only transform float position");
      }
      int[] data=Arrays.copyOf(quad.getVertexData(),quad.getVertexData().length);
      int shift=data.length / 4;
      for (int v=0; v < 4; v++) {
        float[] pos=new float[]{0f,0f,0f,1f};
        for (int i=0; i < Math.min(4,e.getElementCount()); i++) {
          pos[i]=Float.intBitsToFloat(data[shift * v + e.getOffset() / 4 + i]);
        }
        Vector4f vec=new Vector4f(pos);
        transform.getMatrix().transform(vec);
        vec.get(pos);
        for (int i=0; i < Math.min(4,e.getElementCount()); i++) {
          data[shift * v + e.getOffset() / 4 + i]=Float.floatToRawIntBits(pos[i]);
        }
      }
      return new BakedQuad(data,quad.getTintIndex(),quad.getFace());
    }
  }
  return quad;
}

{
  if (check) {
    List<World> allWorlds=Lists.newArrayList(weakWorldMap.keySet());
    allWorlds.removeAll(worlds.values());
    Set<Integer> newLeaks=Sets.newHashSet();
    for (ListIterator<World> li=allWorlds.listIterator(); li.hasNext(); ) {
      World w=li.next();
      if (leakedWorlds.contains(System.identityHashCode(w))) {
        li.remove();
      }
      newLeaks.add(System.identityHashCode(w));
    }
    leakedWorlds=newLeaks;
    if (allWorlds.size() > 0) {
      FMLLog.severe("Detected leaking worlds in memory. There are %d worlds that appear to be persisting. A mod is likely caching the world incorrectly\n",allWorlds.size() + leakedWorlds.size());
      for (      World w : allWorlds) {
        FMLLog.severe("The world %x (%s) has leaked.\n",System.identityHashCode(w),w.getWorldInfo().getWorldName());
      }
    }
  }
  return getIDs();
}

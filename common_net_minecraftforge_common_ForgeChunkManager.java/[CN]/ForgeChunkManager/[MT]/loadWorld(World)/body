{
  ArrayListMultimap<String,Ticket> newTickets=ArrayListMultimap.<String,Ticket>create();
  tickets.put(world,newTickets);
  SetMultimap<ChunkCoordIntPair,Ticket> forcedChunkMap=LinkedHashMultimap.create();
  forcedChunks.put(world,forcedChunkMap);
  if (!(world instanceof WorldServer)) {
    return;
  }
  WorldServer worldServer=(WorldServer)world;
  File chunkDir=worldServer.getChunkSaveLocation();
  File chunkLoaderData=new File(chunkDir,"forcedchunks.dat");
  if (chunkLoaderData.exists() && chunkLoaderData.isFile()) {
    ArrayListMultimap<String,Ticket> loadedTickets=ArrayListMultimap.<String,Ticket>create();
    NBTTagCompound forcedChunkData;
    try {
      forcedChunkData=CompressedStreamTools.read(chunkLoaderData);
    }
 catch (    IOException e) {
      FMLLog.log(Level.WARNING,e,"Unable to read forced chunk data at %s - it will be ignored",chunkLoaderData.getAbsolutePath());
      return;
    }
    NBTTagList ticketList=forcedChunkData.getTagList("TicketList");
    for (int i=0; i < ticketList.tagCount(); i++) {
      NBTTagCompound ticketHolder=(NBTTagCompound)ticketList.tagAt(i);
      String modId=ticketHolder.getString("Owner");
      if (!Loader.isModLoaded(modId)) {
        FMLLog.warning("Found chunkloading data for mod %s which is currently not available or active - it will be removed from the world save",modId);
        continue;
      }
      if (!callbacks.containsKey(modId)) {
        FMLLog.warning("The mod %s has registered persistent chunkloading data but doesn't seem to want to be called back with it - it will be removed from the world save",modId);
        continue;
      }
      NBTTagList tickets=ticketHolder.getTagList("Tickets");
      for (int j=0; j < tickets.tagCount(); j++) {
        NBTTagCompound ticket=(NBTTagCompound)tickets.tagAt(j);
        Type type=Type.values()[ticket.getByte("Type")];
        byte ticketChunkDepth=ticket.getByte("ChunkListDepth");
        Ticket tick=new Ticket(modId,type,world);
        if (ticket.hasKey("ModData")) {
          tick.modData=ticket.getCompoundTag("ModData");
        }
        if (type == Type.ENTITY) {
          tick.entityChunkX=ticket.getInteger("chunkX");
          tick.entityChunkZ=ticket.getInteger("chunkZ");
          UUID uuid=new UUID(ticket.getLong("PersistentIDMSB"),ticket.getLong("PersistentIDLSB"));
          pendingEntities.put(uuid,tick);
        }
        loadedTickets.put(modId,tick);
      }
    }
    for (    Ticket tick : ImmutableSet.copyOf(pendingEntities.values())) {
      if (tick.ticketType == Type.ENTITY && tick.entity == null) {
        world.getChunkFromChunkCoords(tick.entityChunkX,tick.entityChunkZ);
      }
    }
    for (    Ticket tick : ImmutableSet.copyOf(pendingEntities.values())) {
      if (tick.ticketType == Type.ENTITY && tick.entity == null) {
        FMLLog.warning("Failed to load persistent chunkloading entity %s from store.",pendingEntities.inverse().get(tick));
        loadedTickets.remove(tick.modId,tick);
      }
    }
    pendingEntities.clear();
    for (    String modId : loadedTickets.keySet()) {
      LoadingCallback loadingCallback=callbacks.get(modId);
      int maxTicketLength=getMaxTicketLengthFor(modId);
      List<Ticket> tickets=loadedTickets.get(modId);
      if (loadingCallback instanceof OrderedLoadingCallback) {
        OrderedLoadingCallback orderedLoadingCallback=(OrderedLoadingCallback)loadingCallback;
        tickets=orderedLoadingCallback.ticketsLoaded(ImmutableList.copyOf(tickets),world,maxTicketLength);
      }
      if (tickets.size() > maxTicketLength) {
        FMLLog.warning("The mod %s has too many open chunkloading tickets %d. Excess will be dropped",modId,tickets.size());
        tickets.subList(maxTicketLength,tickets.size()).clear();
      }
      ForgeChunkManager.tickets.get(world).putAll(modId,tickets);
      loadingCallback.ticketsLoaded(ImmutableList.copyOf(tickets),world);
    }
  }
}

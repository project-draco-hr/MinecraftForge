{
  dependencies=new ArrayList<String>();
  preDependencies=new ArrayList<String>();
  postDependencies=new ArrayList<String>();
  if (mod.getPriorities() == null || mod.getPriorities().length() == 0) {
    return;
  }
  boolean parseFailure=false;
  StringTokenizer st=new StringTokenizer(mod.getPriorities(),";");
  for (; st.hasMoreTokens(); ) {
    String dep=st.nextToken();
    String[] depparts=dep.split(":");
    if (depparts.length < 2) {
      parseFailure=true;
    }
 else     if ("required-before".equals(depparts[0]) || "required-after".equals(depparts[0])) {
      if (!depparts[1].trim().equals("*")) {
        dependencies.add(depparts[1]);
      }
 else {
        parseFailure=true;
      }
    }
 else     if ("required-before".equals(depparts[0]) || "before".equals(depparts[0])) {
      postDependencies.add(depparts[1]);
    }
 else     if ("required-after".equals(depparts[0]) || "after".equals(depparts[0])) {
      preDependencies.add(depparts[1]);
    }
 else {
      parseFailure=true;
    }
  }
  if (parseFailure) {
    FMLCommonHandler.instance().getFMLLogger().warning(String.format("The mod %s has an incorrect dependency string {%s}",mod.getPriorities()));
  }
}

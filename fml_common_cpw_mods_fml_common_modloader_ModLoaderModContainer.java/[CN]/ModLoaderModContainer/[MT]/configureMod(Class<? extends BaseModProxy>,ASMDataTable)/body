{
  File configDir=Loader.instance().getConfigDir();
  File modConfig=new File(configDir,String.format("%s.cfg",getModId()));
  Properties props=new Properties();
  boolean existingConfigFound=false;
  boolean mlPropFound=false;
  if (modConfig.exists()) {
    try {
      FMLLog.fine("Reading existing configuration file for %s : %s",getModId(),modConfig.getName());
      FileReader configReader=new FileReader(modConfig);
      props.load(configReader);
      configReader.close();
    }
 catch (    Exception e) {
      FMLLog.log(Level.SEVERE,e,"Error occured reading mod configuration file %s",modConfig.getName());
      throw new LoaderException(e);
    }
    existingConfigFound=true;
  }
  StringBuffer comments=new StringBuffer();
  comments.append("MLProperties: name (type:default) min:max -- information\n");
  List<ModProperty> mlPropFields=Lists.newArrayList();
  try {
    for (    ASMData dat : Sets.union(asmData.getAnnotationsFor(this).get("net.minecraft.src.MLProp"),asmData.getAnnotationsFor(this).get("MLProp"))) {
      if (dat.getClassName().equals(modClazzName)) {
        try {
          mlPropFields.add(new ModProperty(modClazz.getDeclaredField(dat.getObjectName()),dat.getAnnotationInfo()));
          FMLLog.finest("Found an MLProp field %s in %s",dat.getObjectName(),getModId());
        }
 catch (        Exception e) {
          FMLLog.log(Level.WARNING,e,"An error occured trying to access field %s in mod %s",dat.getObjectName(),getModId());
        }
      }
    }
    for (    ModProperty property : mlPropFields) {
      if (!Modifier.isStatic(property.field().getModifiers())) {
        FMLLog.info("The MLProp field %s in mod %s appears not to be static",property.field().getName(),getModId());
        continue;
      }
      FMLLog.finest("Considering MLProp field %s",property.field().getName());
      Field f=property.field();
      String propertyName=!Strings.nullToEmpty(property.name()).isEmpty() ? property.name() : f.getName();
      String propertyValue=null;
      Object defaultValue=null;
      try {
        defaultValue=f.get(null);
        propertyValue=props.getProperty(propertyName,extractValue(defaultValue));
        Object currentValue=parseValue(propertyValue,property,f.getType(),propertyName);
        FMLLog.finest("Configuration for %s.%s found values default: %s, configured: %s, interpreted: %s",modClazzName,propertyName,defaultValue,propertyValue,currentValue);
        if (currentValue != null && !currentValue.equals(defaultValue)) {
          FMLLog.finest("Configuration for %s.%s value set to: %s",modClazzName,propertyName,currentValue);
          f.set(null,currentValue);
        }
      }
 catch (      Exception e) {
        FMLLog.log(Level.SEVERE,e,"Invalid configuration found for %s in %s",propertyName,modConfig.getName());
        throw new LoaderException(e);
      }
 finally {
        comments.append(String.format("MLProp : %s (%s:%s",propertyName,f.getType().getName(),defaultValue));
        if (property.min() != Double.MIN_VALUE) {
          comments.append(",>=").append(String.format("%.1f",property.min()));
        }
        if (property.max() != Double.MAX_VALUE) {
          comments.append(",<=").append(String.format("%.1f",property.max()));
        }
        comments.append(")");
        if (!Strings.nullToEmpty(property.info()).isEmpty()) {
          comments.append(" -- ").append(property.info());
        }
        if (propertyValue != null) {
          props.setProperty(propertyName,extractValue(propertyValue));
        }
        comments.append("\n");
      }
      mlPropFound=true;
    }
  }
  finally {
    if (!mlPropFound && !existingConfigFound) {
      FMLLog.fine("No MLProp configuration for %s found or required. No file written",getModId());
      return;
    }
    if (!mlPropFound && existingConfigFound) {
      File mlPropBackup=new File(modConfig.getParent(),modConfig.getName() + ".bak");
      FMLLog.fine("MLProp configuration file for %s found but not required. Attempting to rename file to %s",getModId(),mlPropBackup.getName());
      boolean renamed=modConfig.renameTo(mlPropBackup);
      if (renamed) {
        FMLLog.fine("Unused MLProp configuration file for %s renamed successfully to %s",getModId(),mlPropBackup.getName());
      }
 else {
        FMLLog.fine("Unused MLProp configuration file for %s renamed UNSUCCESSFULLY to %s",getModId(),mlPropBackup.getName());
      }
      return;
    }
    try {
      FileWriter configWriter=new FileWriter(modConfig);
      props.store(configWriter,comments.toString());
      configWriter.close();
      FMLLog.fine("Configuration for %s written to %s",getModId(),modConfig.getName());
    }
 catch (    IOException e) {
      FMLLog.log(Level.SEVERE,e,"Error trying to write the config file %s",modConfig.getName());
      throw new LoaderException(e);
    }
  }
}

{
  configModButton.visible=false;
  disableModButton.visible=false;
  modInfo=null;
  if (selectedMod == null)   return;
  ResourceLocation logoPath=null;
  Dimension logoDims=new Dimension(0,0);
  List<String> lines=new ArrayList<String>();
  CheckResult vercheck=ForgeVersion.getResult(selectedMod);
  String logoFile=selectedMod.getMetadata().logoFile;
  if (!logoFile.isEmpty()) {
    TextureManager tm=mc.getTextureManager();
    IResourcePack pack=FMLClientHandler.instance().getResourcePackFor(selectedMod.getModId());
    try {
      BufferedImage logo=null;
      if (pack != null) {
        logo=pack.getPackImage();
      }
 else {
        InputStream logoResource=getClass().getResourceAsStream(logoFile);
        if (logoResource != null)         logo=ImageIO.read(logoResource);
      }
      if (logo != null) {
        logoPath=tm.getDynamicTextureLocation("modlogo",new DynamicTexture(logo));
        logoDims=new Dimension(logo.getWidth(),logo.getHeight());
      }
    }
 catch (    IOException e) {
    }
  }
  if (!selectedMod.getMetadata().autogenerated) {
    disableModButton.visible=true;
    disableModButton.enabled=true;
    disableModButton.packedFGColour=0;
    Disableable disableable=selectedMod.canBeDisabled();
    if (disableable == Disableable.RESTART) {
      disableModButton.packedFGColour=0xFF3377;
    }
 else     if (disableable != Disableable.YES) {
      disableModButton.enabled=false;
    }
    IModGuiFactory guiFactory=FMLClientHandler.instance().getGuiFactoryFor(selectedMod);
    configModButton.visible=true;
    configModButton.enabled=guiFactory != null && guiFactory.mainConfigGuiClass() != null;
    lines.add(selectedMod.getMetadata().name);
    lines.add(String.format("Version: %s (%s)",selectedMod.getDisplayVersion(),selectedMod.getVersion()));
    lines.add(String.format("Mod ID: '%s' Mod State: %s",selectedMod.getModId(),Loader.instance().getModState(selectedMod)));
    if (!selectedMod.getMetadata().credits.isEmpty()) {
      lines.add("Credits: " + selectedMod.getMetadata().credits);
    }
    lines.add("Authors: " + selectedMod.getMetadata().getAuthorList());
    lines.add("URL: " + selectedMod.getMetadata().url);
    if (selectedMod.getMetadata().childMods.isEmpty())     lines.add("No child mods for this mod");
 else     lines.add("Child mods: " + selectedMod.getMetadata().getChildModList());
    if (vercheck.status == Status.OUTDATED || vercheck.status == Status.BETA_OUTDATED)     lines.add("Update Available: " + (vercheck.url == null ? "" : vercheck.url));
    lines.add(null);
    lines.add(selectedMod.getMetadata().description);
  }
 else {
    lines.add(WHITE + selectedMod.getName());
    lines.add(WHITE + "Version: " + selectedMod.getVersion());
    lines.add(WHITE + "Mod State: " + Loader.instance().getModState(selectedMod));
    if (vercheck.status == Status.OUTDATED || vercheck.status == Status.BETA_OUTDATED)     lines.add("Update Available: " + (vercheck.url == null ? "" : vercheck.url));
    lines.add(null);
    lines.add(RED + "No mod information found");
    lines.add(RED + "Ask your mod author to provide a mod mcmod.info file");
  }
  if ((vercheck.status == Status.OUTDATED || vercheck.status == Status.BETA_OUTDATED) && vercheck.changes.size() > 0) {
    lines.add(null);
    lines.add("Changes:");
    for (    Entry<ComparableVersion,String> entry : vercheck.changes.entrySet()) {
      lines.add("  " + entry.getKey() + ":");
      lines.add(entry.getValue());
      lines.add(null);
    }
  }
  modInfo=new Info(this.width - this.listWidth - 30,lines,logoPath,logoDims);
}

{
  try {
    ZipInputStream zipInput=new ZipInputStream(stream);
    ZipEntry entry;
    while ((entry=zipInput.getNextEntry()) != null) {
      byte[] data=new byte[(int)entry.getSize()];
      int i=0;
      while (zipInput.available() > 0 && i < data.length) {
        data[i++]=(byte)zipInput.read();
      }
      zipContents.put(entry.getName(),data);
    }
    byte[] modelXml=zipContents.get("model.xml");
    if (modelXml == null) {
      throw new ModelFormatException("Model " + fileName + " contains no model.xml file");
    }
    DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance();
    DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder();
    Document document=documentBuilder.parse(new ByteArrayInputStream(modelXml));
    NodeList nodeListTechne=document.getElementsByTagName("Techne");
    if (nodeListTechne.getLength() < 1) {
      throw new ModelFormatException("Model " + fileName + " contains no Techne tag");
    }
    NodeList nodeListModel=document.getElementsByTagName("Model");
    if (nodeListModel.getLength() < 1) {
      throw new ModelFormatException("Model " + fileName + " contains no Model tag");
    }
    NamedNodeMap modelAttributes=nodeListModel.item(0).getAttributes();
    if (modelAttributes == null) {
      throw new ModelFormatException("Model " + fileName + " contains a Model tag with no attributes");
    }
    Node modelTexture=modelAttributes.getNamedItem("texture");
    if (modelTexture != null) {
      texture=modelTexture.getTextContent();
    }
    NodeList shapes=document.getElementsByTagName("Shape");
    for (int i=0; i < shapes.getLength(); i++) {
      Node shape=shapes.item(i);
      NamedNodeMap shapeAttributes=shape.getAttributes();
      if (shapeAttributes == null) {
        throw new ModelFormatException("Shape #" + (i + 1) + " in "+ fileName+ " has no attributes");
      }
      Node name=shapeAttributes.getNamedItem("name");
      String shapeName=null;
      if (name != null) {
        shapeName=name.getNodeValue();
      }
      if (shapeName == null) {
        shapeName="Shape #" + (i + 1);
      }
      String shapeType=null;
      Node type=shapeAttributes.getNamedItem("type");
      if (type != null) {
        shapeType=type.getNodeValue();
      }
      if (shapeType != null && !cubeTypes.contains(shapeType)) {
        FMLLog.warning("Model shape [" + shapeName + "] in "+ fileName+ " is not a cube, ignoring");
        continue;
      }
      try {
        boolean mirrored=false;
        String[] offset=new String[3];
        String[] position=new String[3];
        String[] rotation=new String[3];
        String[] size=new String[3];
        String[] textureOffset=new String[2];
        NodeList shapeChildren=shape.getChildNodes();
        for (int j=0; j < shapeChildren.getLength(); j++) {
          Node shapeChild=shapeChildren.item(j);
          String shapeChildName=shapeChild.getNodeName();
          String shapeChildValue=shapeChild.getTextContent();
          if (shapeChildValue != null) {
            shapeChildValue=shapeChildValue.trim();
            if (shapeChildName.equals("IsMirrored")) {
              mirrored=!shapeChildValue.equals("False");
            }
 else             if (shapeChildName.equals("Offset")) {
              offset=shapeChildValue.split(",");
            }
 else             if (shapeChildName.equals("Position")) {
              position=shapeChildValue.split(",");
            }
 else             if (shapeChildName.equals("Rotation")) {
              rotation=shapeChildValue.split(",");
            }
 else             if (shapeChildName.equals("Size")) {
              size=shapeChildValue.split(",");
            }
 else             if (shapeChildName.equals("TextureOffset")) {
              textureOffset=shapeChildValue.split(",");
            }
          }
        }
        ModelRenderer cube=new ModelRenderer(this,Integer.parseInt(textureOffset[0]),Integer.parseInt(textureOffset[1]));
        cube.mirror=mirrored;
        cube.addBox(Float.parseFloat(offset[0]),Float.parseFloat(offset[1]),Float.parseFloat(offset[2]),Integer.parseInt(size[0]),Integer.parseInt(size[1]),Integer.parseInt(size[2]));
        cube.setRotationPoint(Float.parseFloat(position[0]),Float.parseFloat(position[1]) - 23.4F,Float.parseFloat(position[2]));
        cube.rotateAngleX=(float)Math.toRadians(Float.parseFloat(rotation[0]));
        cube.rotateAngleY=(float)Math.toRadians(Float.parseFloat(rotation[1]));
        cube.rotateAngleZ=(float)Math.toRadians(Float.parseFloat(rotation[2]));
        parts.put(shapeName,cube);
      }
 catch (      NumberFormatException e) {
        FMLLog.warning("Model shape [" + shapeName + "] in "+ fileName+ " contains malformed integers within its data, ignoring");
        e.printStackTrace();
      }
    }
  }
 catch (  ZipException e) {
    throw new ModelFormatException("Model " + fileName + " is not a valid zip file");
  }
catch (  IOException e) {
    throw new ModelFormatException("Model " + fileName + " could not be read",e);
  }
catch (  ParserConfigurationException e) {
  }
catch (  SAXException e) {
    throw new ModelFormatException("Model " + fileName + " contains invalid XML",e);
  }
}
